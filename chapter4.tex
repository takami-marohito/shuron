\section{システム概要}
本研究で提案するHSIモデルの新しい構築手法について先の章で説明した．
この章ではこれをどのように実現したかについて説明する．

提案手法を実現するシステムの要件は以下のとおりである． \\
(1) 公開してはいけない漁獲実績データを扱う場合がある．
そのため，漁獲実績データを外部へ送信せずにモデル構築する必要がある． \\
(2) 利用者として漁獲モデル構築の専門家だけではなく漁師も想定しているので，システムに対する理解が十分でなくても結果がわかるような可視化を行う必要がある．
そのため地図上で漁場予測を表示することで本システムの結果を可視化する．

この要件を満たすよう設計されたシステム概要は図\ref{fig:4.3}のようになっている．
\begin{figure}
  \begin{center}
    \includegraphics[width=10cm]{4-3.png}
  \end{center}
  \caption{システム概要}
  \label{fig:4.3}
\end{figure}

要件(1)についてはモデル構築を手元のPCで行い，外部とのやり取りをMOVEデータ取得のみに限定することで達成できる．
要件(2)を達成するために漁場予測の分布を地図上で可視化する．
また利用者にとってのインタラクティブ性を向上させるために，地図の平行移動および拡大縮小も行えるようにした．
本研究では提案手法を3つのサブシステムに分けて実装した．

\begin{itemize}
\item{流跡線計算システム}
\item{最適化計算システム}
\item{地図描画システム}
\end{itemize}

各システムで利用する手法については3章で述べたが，それをどのように実現したのかを次節から説明する．

\section{流跡線計算システム}
流跡線計算システムではルンゲクッタ法を用いた流跡線計算を行い，計算結果に沿ったサンプリングを行う．

なお本研究では流跡線に沿ったサンプリングを24時間ごとに行うようにし，流跡線計算を60日まで行う．
また，実測した漁獲位置の中で最も海底が浅い漁獲位置の最大深さインデックスが20なので，深さごとの流跡線計算の始点は深さインデックス20までにする．

このシステムでは60日分の流跡線計算をそれぞれの深さインデックス，それぞれの始点について順に行っている．
各漁獲位置での流跡線計算は他の漁獲位置での流跡線計算と独立している．
そして流跡線計算システムでは各漁獲位置ごとの流跡線計算を順に行うので，漁獲位置情報を分割するだけで別の計算機による分散計算ができる．
本研究で使用する流跡線計算システムは次のようになっている．
\if0
ルンゲクッタ法のためにMOVEデータからデータを取り出すのが結構手間なことを説明する
\fi

\begin{itemize}
\item[]{流跡線計算を行いたい漁獲位置の座標と日付を読み込む}
\item[]{for i=0;i$<$(流跡線計算を行いたい漁獲位置の数);i++}
\item[]{\ \ \ \ for d=0;d$<$(深さインデックスの数);d++}
\item[]{\ \ \ \ \ \ \ \ i番目の始点のd番目の深さインデックスの地点を計算開始点にする}
\item[]{\ \ \ \ \ \ \ \ for t=0;t$<$(遡りたい日数);t++}
\item[]{\ \ \ \ \ \ \ \ \ \ \ \ 時刻tでの3次元流速と時刻t+1での3次元流速を取得}
\item[]{\ \ \ \ \ \ \ \ \ \ \ \ ルンゲクッタ法を用いて24時間前の3次元座標を求める}
\item[]{\ \ \ \ \ \ \ \ \ \ \ \ 時刻t+1での各海洋環境変数を取得}
\item[]{\ \ \ \ \ \ \ \ \ \ \ \ 先のステップで求めた3次元座標での変数を補間し記録する}
\item[]{\ \ \ \ \ \ \ \ end for t}
\item[]{\ \ \ \ end for d}
\item[]{end for i}
\end{itemize}

3章で説明したように，MOVEデータをOPeNDAPで取得する際に特定の深さでの水平な格子データが一度に取得できる．
そしてある深さでの値を補間するためにはその深さと隣接した2つの深さのデータから線形補間で計算を行う．
これを3次元それぞれの速度で行うので，ある3次元座標点での流速を補間するためには6回のMOVEデータ取得が必要となる．
3章で説明したようにこのアルゴリズムでは一日前の流跡線を計算するためにルンゲクッタ法による流跡線計算を3回行っておりそれぞれの流速はMOVEデータから計算を行う．
MOVEデータでは一日ごとに各格子点での流速が計算されているので時間での補間は一日ごとの流速データから行う．
そのため，一日前の流跡線計算には合計12回のMOVEデータ取得が必要となる．
そのようにして求めた一日前の座標で流速の他に海水温と塩分濃度の2種類の海洋環境変数を線形補間する．
そのため先の12回と合わせて合計16回のMOVEデータ取得を行うことで単一の漁獲位置の一日前の各海洋環境変数の計算ができる．
単一の漁獲位置ではこれを60日，20段階の深さインデックスについて行うので，単一の漁獲位置から得られる海洋環境変数を全て計算するためには19200回のMOVEデータ取得が必要である．
本実験で使用する漁獲実績データでは合計で366点の観測データがあるので，すべての海洋環境変数の計算をするために702万7200回のMOVEデータ取得を行った．

\section{最適化計算システム}
最適化計算システムでは流跡線計算システムの結果として計算された，過去のデータを含む海洋環境変数を入力としHSIモデル構築に必要な各SIモデル式を計算する．

IRLSアルゴリズムで解くべき式は式\ref{eq:3-16-3}および式\ref{eq:3-17}である．
式\ref{eq:3-17}は式\ref{eq:3-16-3}の結果から一意に解くことができる．
式\ref{eq:3-16-3}は各行列を次のように構成することができる．
Yは$n \times 1$行列でそのi行目はi番目の漁獲位置で実測した漁獲量となっている．
Xは$n \times m$行列でそのi行目はi番目の漁獲位置の流跡線を計算することで得られる単一の海洋環境変数を全て横に並べた行列である．
$\lambda$は罰則項の重みである．

しかしこのままだと水平方向の流速についてのSIモデルを構築する際に問題が生じることがある．
水平方向の流速はおおよそ最大値が100cm/s，最小値が0.05cm/sとなっている．
そのため式\ref{eq:3-16-3}の行列Xの各項は最大1000倍以上の差ができる．
例えば流速の中で一つの変数が，SIモデルを構築する際は0.05cm/s付近の値を取り，未知の漁獲量を計算する際は100cm/s付近の値を取るような場合を考える．
この場合SIモデル内のその変数にかかる係数は大きくなる．
さらに未知の漁獲量を計算する際には変数も大きな値を取るのでSIモデルではその変数が支配的になってしまう．
このようにSIモデルを構築した際に意図した各変数の影響の大きさと，実際の計算結果での各変数の影響の大きさが異なるSIモデルとなる．
この問題を回避するために式\ref{eq:3-16-3}の変数Xにlogをかけた．
こうすることで式\ref{eq:3-16-3}の行列Xの各項の差が小さくなり，未知の漁獲量を計算した結果で各変数の影響が変化しにくい．
つまり，最適化計算システムでは$\log X = X^{*}$を使い，式\ref{eq:3-16-3}ではなく式\ref{eq:4-10}を解いている．

\begin{eqnarray}
\label{eq:4-10}
\left( X^{*T}X^{*} + \lambda W^{(t)} \right) \theta^{(t+1)} = X^{*}Y
\end{eqnarray}

一方で式\ref{eq:3-1}の両辺にlogをかけた場合，式\ref{eq:4-10}ではなく式\ref{eq:4-11}になる．

\begin{eqnarray}
\label{eq:4-11}
\left( X^{*T}X^{*} + \lambda W^{(t)} \right) \theta^{(t+1)} = X^{*}Y^{*}
\end{eqnarray}

この方が解法としては自然であるが，式\ref{eq:4-11}では正答率を計算する際に問題が生じる．
正答率を計算する時に漁獲量の平均を計算するが，例えば$10^3$と$10^1$の平均を求める場合を考える．
算術平均では505となるが，logをかけた場合は平均が$10^2=100$となる．
漁獲予測としての正答率を求める際は算術平均が適切なので，正答率を計算する際に漁獲量のlogを元に戻す作業が必要となる．
その処理を省略するために式\ref{eq:4-11}ではなく式\ref{eq:4-10}を解いている．

行列Xは流跡線上でサンプリングした海洋環境変数を並べた行列である．
そのためXの一部の成分が0や負の数となる可能性がある．
その場合logをかけると行列Xが特異行列となりモデル構築ができない．
これを回避するためにまず0の場合は$10^{-8}$に置き換える．
次にすべての海洋環境変数は絶対値をとった上でlogをかけた．

本研究では0から1まで0.01ごとに用意したそれぞれの$\lambda$の場合でSIモデルを計算し正答率が最大かつ最も$\lambda$が大きくなるSIモデルを計算結果のSIモデルとして出力する．

最適化計算システムはmatlabで実装した．
IRLSアルゴリズムでは{\bf Ax}={\bf b}を満たす{\bf x}を計算する必要があるが，matlabではこれを計算する関数としてmldivide関数がある．
今回，{\bf Ax}={\bf b}に相当する方程式は式\ref{eq:3-16-3}となる．
この内，{\bf A}に相当する$X^{T}X + \lambda W^{(t)}$は$n \times n$行列となっている（nはモデル構築に使用する海洋環境変数の数）．
この場合，mldivide関数は$X^{T}X + \lambda W^{(t)}$を下三角行列{\bf L}と上三角行列{\bf U}に分解するLU分解を行うことで式\ref{eq:4-1}の変形をまず行う．
\if0
LU分解をどうやってやるのか
\fi

\begin{eqnarray}
\label{eq:4-1}
{\bf Ax} = {\bf LUx} = {\bf b}
\end{eqnarray}

式\ref{eq:4-1}は${\bf L}({\bf Ux}) = {\bf b}$ となり，これを{\bf Ux}について解く場合はちょうどガウスの消去法の前進消去となるので{\bf Ux}が求まる．
{\bf Ux}は同様にガウスの消去法の後退代入となるので，{\bf x}が求まる．
このようにすることで，{\bf Ax}={\bf b}から{\bf x}を求める場合，${\bf A}^{-1}$を求める必要はない．
つまり，式\ref{eq:3-16-3}を$\theta$について解く場合，$\left( X^{T}X + \lambda W^{(t)} \right) ^{-1}$を求める必要が無いということである．
以上のようにしてIRLSアルゴリズムでの$\theta$の更新を行っている．

最適化計算システム全体のアルゴリズムは次のようになっている．

\begin{itemize}
\item[]{読み込んだ漁獲位置を学習データとテストデータに分割する}
\item[]{for $\lambda = 0;\lambda<1.0;\lambda=\lambda$+0.01}
\item[]{\ \ \ \ IRLSアルゴリズムを用いてモデルを構築し係数行列$\theta$を求める}
\item[]{\ \ \ \ 構築したモデルの正答率を求める}
\item[]{\ \ \ \ if ( 正答率 $>$ 最大正答率)}
\item[]{\ \ \ \ \ \ \ \ $\theta$と$\lambda$と正答率を暫定的に保持する}
\item[]{\ \ \ \ end if}
\item[]{end for}
\item[]{最大正答率となる$\theta$と$\lambda$を出力する}
\end{itemize}

これを各海洋環境変数ごとに行うことで各SIモデルを構築できる．
このようにして構築したSIモデルを次の地図描画システムに送ることで漁獲モデルによる予測の分布が可視化できる．
このシステムでは各SIモデル構築を独立して行うことができるので，別の計算機を用いた分散計算が可能となっている．

本研究で構築するSIモデルは式\ref{eq:3-1}の形になっている．
そのため最適化計算システムでの計算結果は使用変数名，その係数の行列の形で表すことができ，その形で地図描画システムへデータを渡している．


\section{地図描画システム}
地図描画システムでは最適化計算システムの結果として得られた係数行列$\theta$を基にHSIモデルを構築し，HSIモデルから漁獲モデルを計算し，地図に描画することで可視化を行う．
そのため，漁獲量予測を行い，その正答率を求めて評価する部分はこのシステムが担当している．

最適化計算システムですでに各SIモデルが構築できているので，3章で説明したようにそれらの相乗平均をとることでHSIモデルを構築する．
一方直接HSIモデルを求める手法ではこの段階は省く．
そしてHSIモデルから計算される漁獲モデルの評価を行うために3章で説明した正答率をこの漁獲モデルに対して求める．

構築した漁獲モデルは3章で説明した手順でCPUEの予測として可視化する．
本研究では過去の関連研究\cite{a7} \cite{related3} \cite{related5}と同様に，地図の海の部分を色分けすることで可視化した．

また，地図描画システムにはJavaScriptを使用し，地図描画にthree.jsライブラリを使用した．
three.jsはWebGLをJavaScript上で操作するライブラリで3Dの描画ができる．
これを2D的に扱うことで地図を実現した．
システムを実行するとまず陸地を描画する（図\ref{fig:4.2}）．

\begin{figure}
  \begin{center}
    \includegraphics[width=7cm]{4-2.png}
  \end{center}
  \caption{地図描画システムの初期状態．海の部分はまだ描画していない．メルカトル図法で地図を描画している．}
  \label{fig:4.2}
\end{figure}

陸地データとしてhttp://www.naturalearthdata.com/にある1:10,000,000スケールの陸地データを用いた．
このデータには陸地情報として陸地の各頂点が緯度経度の座標系で入っている．
それを頂点としたMultiPolygonをthree.jsで描画し黒色で塗りつぶすことで陸地ができる．
また，地図は一般になじみ深いメルカトル図法で描画している．
メルカトル図法では地図上での経度の単位長さは一定だが，緯度の単位長さは緯度によって変化する．
\if0
この式は追記が必要
システムだと
x = 10*a
y = MAP_COE * ln()
になってる
MAP_COEとかを式に追記
\fi
そのため，単に緯度経度に比例した座標変換ではメルカトル図法の地図が作れない．
緯度経度が東経a度，北緯b度の点は地図の座標系で次式のxyに変換する必要がある．

\begin{eqnarray}
x = a \\
y = ln \left( tan \left( 45^{\circ} + b^{\circ} \right) \right) 
\end{eqnarray}

地図を描画する際の位置情報は全て緯度経度なのでこの式を全ての位置情報に適用して地図の座標系に変換する．
\if0
海の描画はthree.jsの三角形ポリゴンを描画する機能で実現している．
本研究で計算した漁獲予測は計算に使用したMOVEデータの格子点上で行うので，その解像度はMOVEデータの解像度である緯度経度0.1度と同じである．
格子は地図上では長方形であるが，これを2つの三角形に分割して描画する．
そうすることで各頂点に与えた色を線形に補間できるようになる．
海の解像度は陸地の解像度より低いので陸地と海の境界が詳細になるよう，陸地の背後に配置した．
\fi
\if0
以上のようにして陸地と海を構成した．
これを通常の3次元空間の見え方と同じ見え方を実現するPerspectiveCameraで見ると，近くのものが大きく見え遠くのものが小さく見える．
そのため陸地と海の境界付近で，本来海の描画結果を見たい部分が陸地に隠されてしまう．
そこでOrthographicCameraを使用した．
OrthographicCameraはカメラの射影面を決め，平面状の射影面の各ピクセルから射影面と垂直に直線を引き，その直線上でサンプリングすることでそのピクセルの色を決定するカメラである．
一方のPerspectiveCameraはカメラの視点から単位距離離れた場所に視野の長方形を設定することで射影面を決め，視点から射影面の各ピクセルに向かって直線を引き，その直線上でサンプリングすることでそのピクセルの色を決定するカメラである．
OrthograhicCameraは射影面が平面であることから，視点からの距離によって物体の見た目の大きさが変化せず今回の地図描画に適している．
\fi
\if0
それぞれのカメラの図をつける
\fi
\if0
さらに漁獲予測分布を見る際にインタラクティブ性を高めるために，地図描画システムではマウスを用いた地図の拡大縮小機能と視点移動機能を追加した．
これらの機能は全てOrthographicCameraのパラメータ変更によって実現できる．
OrthographicCameraでは視点の中心，視線の方向，描画する範囲を設定することで一つの見え方を決定できる．
この中で視点の中心を，射影面と水平に動かすとちょうど見え方も水平移動するようになる．
例えばマウスで地図をドラッグした際に視点移動を実現したい場合は，マウスの移動に合わせて視点の中心を射影面と水平に移動することでできる．
マウスのホイールを操作することで拡大する場合は，地図そのものの大きさは変化させずにカメラが描画する範囲を狭くすることで結果として地図の拡大が実現できる．
縮小はちょうどその逆で地図全体の大きさを変化させずにカメラが描画する範囲を広くすることで実現できる．
\fi
\if0
また，漁獲予測分布のカラーマップも過去の関連研究\cite{related5}と同様に，青→緑→赤の順に予測したCPUEが大きくなるように設定する．
一般によく使われるRGB色空間は赤緑青を成分とする色空間である．
これを用いて青→緑→赤の滑らかな色変化を実現するためには，赤緑青の各成分を操作するために3つの非線形な変換式が必要になる．
そのためこの色の変化を実現するためにHSL色空間に基づいたカラーマップを用いた．
HSL色空間は色相(Hue)彩度(Saturation）輝度(Lightness）を成分とする色空間である．
色相は0から360度までの角度で色合いを表し，彩度は0から100\% で色の鮮やかさを表し，輝度は0から100\% で色の明るさを表している．
この中で，色相は0度から順に変化させることで赤→緑→青→紫→赤までなめらかに変化する．
そのため彩度と輝度を一定にしたまま色相を240度から0度まで変化させることで青→緑→赤の色の変化を単一の線形な式で表現できる．
本研究では純色で表すために彩度を100\% ，輝度を50\% とした．
そしてCPUEの予測値と色相の変換は次式で行った．

\begin{eqnarray}
Hue = 240 \cdot \left( 1 - \frac{CPUE - CPUE_{min}}{CPUE_{max}-CPUE_{min}} \right)
\end{eqnarray}

この式で$CPUE_{min} = -1$，$CPUE_{max}=1$とした時の色の分布は図\ref{fig:4.1}となる．
\begin{figure}
  \begin{center}
    \includegraphics[width=7cm]{4-1.png}
  \end{center}
  \caption{HSL色空間を基にしたカラーマップでの色の分布}
  \label{fig:4.1}
\end{figure}

先の式で用いた$CPUE_{min}$と$CPUE_{max}$は計算した全てのCPUEの最大最小とする方法や，特定の範囲の最大最小とする方法，CPUEの計算結果にかかわらず一定にする方法がありえる．
各方法のどれが最適なのかは実際に可視化して比較する必要がある．
そのため，地図描画システムでは可視化結果を見てから各方法で可視化し直すことができるようにした．
\fi
構築したHSIモデルの分布を描画するためにはある程度の範囲で流跡線計算とサンプリングを行った座標点群が必要である．
しかし，ここまでの流跡線計算はすべて実測した漁獲位置上を始点として行っている．
そのためこれまでの計算とは別に，分布を知りたい範囲で流跡線計算を行う必要がある．
そこで分布を知りたい範囲を格子状に区切りその頂点を記録する．
それらを始点として，先の流跡線計算システムで流跡線計算と流跡線上でのサンプリングを予め行う．
こうすることで利用者にとっての最終結果であるCPUE予測の分布を可視化できる．

地図描画システムのアルゴリズムは次のようになる．

\begin{enumerate}
\item{陸地を描画する}
\item{最適化計算プログラムで計算した各SIモデルデータを読み込む}
\item{分布を描画したい範囲での各格子点を始点とした流跡線に沿ってサンプリングした海洋環境変数データを読み込む}
\item{陸地の下になるように海を描画する}
\end{enumerate}