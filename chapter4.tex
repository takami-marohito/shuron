\section{プログラム全体}
本研究で提案するHSIモデルの新しい構築手法について先の章で説明した。
この章ではその手法を実際にどのように実装したかについて説明する。

本研究では提案手法を3つのプログラムに分けて実装した。

\begin{itemize}
\item{流跡線計算プログラム}
\item{最適化計算プログラム}
\item{地図描画プログラム}
\end{itemize}

各プログラムについて次節から説明する。

\section{流跡線計算プログラム}
流跡線計算プログラムではルンゲクッタ法を用いた流跡線計算を行い、計算結果に沿ったサンプリングを行う。

なお本研究では流跡線に沿ったサンプリングを24時間ごとに行うようにし、流跡線計算を60日まで行う。
また、実測した漁獲点の中で最も海底が浅い点の最大深さインデックスが20なので、深さごとの流跡線計算の始点は深さインデックス20までにする。

このプログラムでは60日分の流跡線計算をそれぞれの深さインデックス、それぞれの始点について順に行っている。
各漁獲点での流跡線計算は他の点での流跡線計算と独立している。
そして流跡線計算プログラムでは各点ごとの流跡線計算を順に行うので、始点情報を分割するだけで別の計算機による分散計算ができる。
本研究で使用する流跡線計算プログラムは次のようになっている。
\if0
ルンゲクッタ法のためにMOVEデータからデータを取り出すのが結構手間なことを説明する
\fi

\begin{enumerate}
\item{i=0にする}
\item{流跡線計算を行いたい始点の座標と日付を読み込む}
\item{次の4-14ステップをi=（流跡線計算を行いたい点の数）まで繰り返す}
\item{d=0にする}
\item{次の6-13ステップをd=20まで繰り返す}
\item{i番目の始点のd番目の深さインデックスの地点を流跡線計算の開始点にする。}
\item{t=0にする}
\item{次の9-12ステップをt=60まで繰り返す}
\item{tに対応する日付での3次元流速とt+1に対応する日付での3次元流速をMOVEデータから読み込む}
\item{ルンゲクッタ法を用いて24時間前の3次元座標を求める}
\item{t+1に対応する日付での各海洋環境変数をMOVEデータから読み込み、ステップ7で求めた座標での変数を補間し記録する}
\item{t=t+1にする}
\item{d=d+1にする}
\item{i=i+1にする}
\end{enumerate}

3章で説明したように、MOVEデータをOPeNDAPで取得する際に特定の深さでの水平な格子データが一度に取得できる。
そしてある深さでの値を補間するためにはその深さと隣接した2つの深さのデータから線形補間で計算を行う。
これを3次元それぞれの速度で行うので、ある点での流速を補間するためには6回のMOVEデータ取得が必要となる。
3章で説明したようにこのアルゴリズムでは一日前の流跡線を計算するためにルンゲクッタ法による流跡線計算を3回行っておりそれぞれの流速はMOVEデータから計算を行う。
MOVEデータでは一日ごとに各格子点での流速が計算されているので時間での補間は一日ごとの流速データから行う。
そのため、一日前の流跡線計算には合計12回のMOVEデータ取得が必要となる。
そのようにして求めた一日前の点で流速の他に海水温と塩分濃度の2種類の海洋環境変数を線形補間する。
そのため先の12回と合わせて合計16回のMOVEデータ取得を行うことで単一の点の一日前の各海洋環境変数の計算ができる。
単一の漁獲点ではこれを60日、20段階の深さインデックスについて行うので、単一の漁獲点から得られる海洋環境変数を全て計算するためには19200回のMOVEデータ取得が必要である。
本実験で使用する漁獲実績データでは合計で366点の観測データがあるので、すべての海洋環境変数の計算をするために702万7200回のMOVEデータ取得を行った。

\section{最適化計算プログラム}
最適化計算プログラムでは流跡線計算プログラムの結果として計算された、過去のデータを含む海洋環境変数を入力としHSIモデル構築に必要な各SIモデル式を計算する。

IRLSアルゴリズムで解くべき式は式\ref{eq:3-16-3}および式\ref{eq:3-17}である。
式\ref{eq:3-17}は式\ref{eq:3-16-3}の結果から一意に解くことができる。
式\ref{eq:3-16-3}は各行列を次のように構成して解くことができる。
Yは$n \times 1$行列でそのi行目はi番目の漁獲点で実測した漁獲量となっている。
Xは$n \times m$行列でそのi行目はi番目の漁獲点の流跡線を計算することで得られる単一の海洋環境変数を全て横に並べた行列である。
$\lambda$は罰則項の重みである。
本研究では0から1まで0.01ごとに用意したそれぞれの$\lambda$の場合でSIモデルを計算し正答率が最大かつ最も$\lambda$が大きくなるSIモデルを計算結果のSIモデルとして出力する。

最適化計算プログラムはmatlabで実装した。
IRLSアルゴリズムでは{\bf Ax}={\bf b}を満たす{\bf x}を計算する必要があるが、matlabではこれを計算する関数としてmldivide関数がある。
今回、{\bf Ax}={\bf b}に相当する方程式は式\ref{eq:3-16-3}となる。
この内、{\bf A}に相当する$X^{T}X + \lambda W^{(t)}$は$n \times n$行列となっている（nはモデル構築に使用する海洋環境変数の数）。
この場合、mldivide関数は$X^{T}X + \lambda W^{(t)}$を下三角行列{\bf L}と上三角行列{\bf U}に分解するLU分解を行うことで式\ref{eq:4-1}の変形をまず行う。
\if0
LU分解をどうやってやるのか
\fi

\begin{eqnarray}
\label{eq:4-1}
{\bf Ax} = {\bf LUx} = {\bf b}
\end{eqnarray}

式\ref{eq:4-1}は${\bf L}({\bf Ux}) = {\bf b}$ となり、これを{\bf Ux}について解く場合はちょうどガウスの消去法の前進消去となるので{\bf Ux}が求まる。
{\bf Ux}は同様にガウスの消去法の後退代入となるので、{\bf x}が求まる。
このようにすることで、{\bf Ax}={\bf b}から{\bf x}を求める場合、${\bf A}^{-1}$を求める必要はない。
つまり、式\ref{eq:3-16-3}を$\theta$について解く場合、$\left( X^{T}X + \lambda W^{(t)} \right) ^{-1}$を求める必要が無いということである。
以上のようにしてIRLSアルゴリズムでの$\theta$の更新を行っている。

最適化計算プログラム全体のアルゴリズムは次のようになっている。

\begin{enumerate}
\item{読み込んだ漁獲点を学習データとテストデータに分割する}
\item{$\lambda = 0$にする}
\item{次の4-7ステップを$\lambda = 1$まで繰り返す}
\item{IRLSアルゴリズムを用いてモデルを構築し係数行列$\theta$を求める}
\item{構築したモデルの正答率を求める}
\item{正答率がそれまでの最大正答率以上であれば$\theta$と$\lambda$と正答率を暫定的に保持する}
\item{$\lambda = \lambda+0.01$}
\item{最大正答率となる$\theta$と$\lambda$を出力する}
\end{enumerate}

これを各海洋環境変数ごとに行うことで各SIモデルを構築できる。
このようにして構築したSIモデルを次の地図描画プログラムに送ることで漁獲モデルによる予測の分布が可視化できる。
このプログラムでは各SIモデル構築を独立して行うことができるので、別の計算機を用いた分散計算が可能となっている。

本研究で構築するSIモデルは式\ref{eq:3-1}の形になっている。
そのため最適化計算プログラムでの計算結果は使用変数名、その係数の行列の形で表すことができ、その形で地図描画プログラムへデータを渡している。


\section{地図描画プログラム}
地図描画プログラムでは最適化計算プログラムの結果として得られた係数行列$\theta$を基にHSIモデルを構築し、地図に描画することで可視化を行う。
そのため、漁獲量予測を行い、その正答率を求めて評価する部分はこのプログラムが担当している。

最適化計算プログラムですでに各SIモデルが構築できているので、3章で説明したようにそれらの相乗平均をとることでHSIモデルを構築する。
そしてその評価を行うために3章で説明した正答率をこのHSIモデルに対して求める。

構築したHSIモデルは3章で説明した手順でCPUEの予測として可視化する。
本研究では過去の関連研究\cite{a7} \cite{related3} \cite{related5}と同様に、地図の海の部分を色分けすることで可視化した。

また、地図描画プログラムにはJavaScriptを使用し、地図描画にthree.jsライブラリを使用した。
three.jsはWebGLをJavaScript上で操作するライブラリで3Dの描画ができる。
これを2D的に扱うことで地図を実現した。
プログラムを実行するとまず陸地を描画する（図\ref{fig:4.2}）。

\begin{figure}
  \begin{center}
    \includegraphics[width=7cm]{4-2.png}
  \end{center}
  \caption{地図描画プログラムの初期状態。海の部分はまだ描画していない。メルカトル図法で地図を描画している。}
  \label{fig:4.2}
\end{figure}

陸地データとしてhttp://www.naturalearthdata.com/にある1:10,000,000スケールの陸地データを用いた。
このデータには陸地情報として陸地の各頂点が緯度経度の座標系で入っている。
それを頂点としたMultiPolygonをthree.jsで描画し黒色で塗りつぶすことで陸地ができる。
また、地図は一般になじみ深いメルカトル図法で描画している。
メルカトル図法では地図上での経度の単位長さは一定だが、緯度の単位長さは緯度によって変化する。
\if0
この式は追記が必要
プログラムだと
x = 10*a
y = MAP_COE * ln()
になってる
MAP_COEとかを式に追記
\fi
そのため、単に緯度経度に比例した座標変換ではメルカトル図法の地図が作れない。
緯度経度が東経a度，北緯b度の点は地図の座標系で次式のxyに変換する必要がある。

\begin{eqnarray}
x = a \\
y = ln \left( tan \left( 45^{\circ} + b^{\circ} \right) \right) 
\end{eqnarray}

地図を描画する際の位置情報は全て緯度経度なのでこの式を全ての位置情報に適用して地図の座標系に変換する。

海の描画はthree.jsの三角形ポリゴンを描画する機能で実現している。
本研究で計算した漁獲予測は計算に使用したMOVEデータの格子点上で行うので、その解像度はMOVEデータの解像度である緯度経度0.1度と同じである。
格子は地図上では長方形であるが、これを2つの三角形に分割して描画する。
そうすることで各頂点に与えた色を線形に補間できるようになる。
海の解像度は陸地の解像度より低いので陸地と海の境界が詳細になるよう、陸地の背後に配置した。

以上のようにして陸地と海を構成した。
これを通常の3次元空間の見え方と同じ見え方を実現するPerspectiveCameraで見ると、近くのものが大きく見え遠くのものが小さく見える。
そのため陸地と海の境界付近で、本来海の描画結果を見たい部分が陸地に隠されてしまう。
そこでOrthographicCameraを使用した。
OrthographicCameraはカメラの射影面を決め、平面状の射影面の各ピクセルから射影面と垂直に直線を引き、その直線上でサンプリングすることでそのピクセルの色を決定するカメラである。
一方のPerspectiveCameraはカメラの視点を中心とした球面上で視野角と視野の範囲を設定することで射影面を決め、球状の射影面の各ピクセルから射影面と垂直に直線を引き、その直線上でサンプリングすることでそのピクセルの色を決定するカメラである。
OrthograhicCameraは射影面が平面であることから、視点からの距離によって物体の見た目の大きさが変化せず今回の地図描画に適している。
\if0
それぞれのカメラの図をつける
\fi

さらに漁獲予測分布を見る際にインタラクティブ性を高めるために、地図描画プログラムではマウスを用いた地図の拡大縮小機能と視点移動機能を追加した。
これらの機能は全てOrthographicCameraのパラメータ変更によって実現できる。
OrthographicCameraでは視点の中心、視線の方向、描画する範囲を設定することで一つの見え方を決定できる。
この中で視点の中心を、射影面と水平に動かすとちょうど見え方も水平移動するようになる。
例えばマウスで地図をドラッグした際に視点移動を実現したい場合は、マウスの移動に合わせて視点の中心を射影面と水平に移動することでできる。
マウスのホイールを操作することで拡大する場合は、地図そのものの大きさは変化させずにカメラが描画する範囲を狭くすることで結果として地図の拡大が実現できる。
縮小はちょうどその逆で地図全体の大きさを変化させずにカメラが描画する範囲を広くすることで実現できる。

\if0
陸地データはhttp://www.naturalearthdata.com/から持ってきた
\fi
\if0
地図はthree js で描いた
メルカトル図法の説明
陸地は海より手前になるようにした
Orthogonal Cameraを使った
拡大縮小をどうしたか
地図のマウス操作はどう計算したか
\fi

また、漁獲予測分布のカラーマップも過去の関連研究\cite{related5}と同様に、青→緑→赤の順に予測したCPUEが大きくなるように設定する。
一般によく使われるRGB色空間は赤緑青を成分とする色空間である。
これを用いて青→緑→赤の滑らかな色変化を実現するためには、赤緑青の各成分を操作するために3つの非線形な変換式が必要になる。
そのためこの色の変化を実現するためにHSL色空間に基づいたカラーマップを用いた。
HSL色空間は色相(Hue)彩度(Saturation）輝度(Lightness）を成分とする色空間である。
色相は0から360度までの角度で色合いを表し、彩度は0から100\% で色の鮮やかさを表し、輝度は0から100\% で色の明るさを表している。
この中で、色相は0度から順に変化させることで赤→緑→青→紫→赤までなめらかに変化する。
そのため彩度と輝度を一定にしたまま色相を240度から0度まで変化させることで青→緑→赤の色の変化を単一の線形な式で表現できる。
本研究では純色で表すために彩度を100\% 、輝度を50\% とした。
そしてCPUEの予測値と色相の変換は次式で行った。

\begin{eqnarray}
Hue = 240 \cdot \left( 1 - \frac{CPUE - CPUE_{min}}{CPUE_{max}-CPUE_{min}} \right)
\end{eqnarray}

この式で$CPUE_{min} = -1$，$CPUE_{max}=1$とした時の色の分布は図\ref{fig:4.1}となる。
\begin{figure}
  \begin{center}
    \includegraphics[width=7cm]{4-1.png}
  \end{center}
  \caption{HSL色空間を基にしたカラーマップでの色の分布}
  \label{fig:4.1}
\end{figure}

先の式で用いた$CPUE_{min}$と$CPUE_{max}$は計算した全てのCPUEの最大最小とする方法や、特定の範囲の最大最小とする方法、CPUEの計算結果にかかわらず一定にする方法がありえる。
各方法のどれが最適なのかは実際に可視化して比較する必要がある。
そのため、地図描画プログラムでは可視化結果を見てから各方法で可視化し直すことができるようにした。

構築したHSIモデルの分布を描画するためにはある程度の範囲で流跡線計算とサンプリングを行った点が必要である。
しかし、ここまでの流跡線計算はすべて実測した漁獲点上を始点として行っている。
そのためこれまでの計算とは別に、分布を知りたい範囲で流跡線計算を行う必要がある。
そこで分布を知りたい範囲を格子状に区切りその頂点を記録する。
それらを始点として、先の流跡線計算プログラムで流跡線計算と流跡線上でのサンプリングを予め行う。
こうすることで利用者にとっての最終結果であるCPUE予測の分布を可視化できる。

地図描画プログラムのアルゴリズムは次のようになる。

\begin{enumerate}
\item{陸地を描画する}
\item{最適化計算プログラムで計算した各SIモデルデータを読み込む}
\item{分布を描画したい範囲での各格子点を始点とした流跡線に沿ってサンプリングした海洋環境変数データを読み込む}
\item{陸地の下になるように海を描画する}
\end{enumerate}