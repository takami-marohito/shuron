本章では，従来手法及び提案手法について述べる。

\section{使用データ}\label{30}
HSI値を求めるためには海洋環境変数データ、対象魚種の漁獲実績データが必要となる。
本研究で使用したこれらのデータについて述べる。

\subsection{海洋環境変数データ}
本研究で使用する海洋環境変数データは、気象庁気象研究所で開発された海洋データ同化システムで作成されたMOVE（MRI Multivariate Ocean Variational Estimation）データである。
この海洋データ同化システムは数値海洋モデル及び同化システムから成るシステムである\cite{a5}。
\if
海洋環境変数データの説明
変数が5種
深さは54段階
格子の縦横
データがカバーする緯度範囲経度範囲
いつだれがどんな計算機で計算したか
\fi

\subsection{過去のデータの計算}
本研究では過去の海洋環境変数を利用することを提案している。
ある地点での漁獲を過去の海洋環境変数から説明する場合、その地点の海水がどこから来たものなのか計算する必要がある。
\if0
双見君の研究でその必要性を説明している
\fi
本研究で使用する海洋環境データは3次元方向の速度も含んでいるので、海水を遡って計算することができる。
そして深さごとに異なる速度を持っているので、それぞれの深さをスタート地点として遡ると全く別の地点にたどり着く。
\if0
moveデータのダウンロードの仕様（日にちと深さを指定する）を説明して、遡るために何度もダウンロードする必要があることと、そのために事前計算とするひつようがあることをせつめいする。
\fi
今回はより正確に過去の地点を遡るために４次のルンゲクッタ法を用いた。

\subsection{ルンゲクッタ法}
ルンゲクッタ法は常微分方程式の数値解を求める手法の一種である。
同じように常微分方程式の数値解を求める手法として、オイラー法がある。
海洋環境変数を使用することである地点から流れを遡る場合、その地点の速度にステップの時間幅をかけることで過去の地点を求める手法がオイラー法である（式\ref{eq:3-20}）。

\begin{eqnarray}
\label{eq:3-20}
(x^{(t-1)}, y^{(t-1)}, z^{(t-1)}) = (x^t , y^t , z^t) - (u^t , v^t , w^t) \cdot \Delta t
\end{eqnarray}

遡っているので速度が負になっている。
オイラー法では速度はそのままその地点の速度を用いて、ステップの時間幅で速度変化がないものとして扱っている。
しかし、実際には微小時間ごとに速度変化は起きている。
ルンゲクッタ法はオイラー法の式である式\ref{eq:3-20}における$u^t$と$v^t$と$w^t$をより正確に求める手法である。
そのため、速度変化が一切ない領域ではどちらの手法も同じ結果となるが、本研究で使用する海洋環境変数データはそのような領域がないため、ルンゲクッタ法による精度向上が期待できる。

4次のルンゲクッタ法は次のように計算する。

\begin{enumerate}
\item k1からk4を計算する
\item k1からk4を重みを付けて平均化する
\item それを速度としてステップの時間幅$\Delta t$をかけることで、移動量とする
\item もとの位置に移動量を足すことで解とする
\end{enumerate}

k1は式\ref{eq:3-21}で計算する。

\begin{eqnarray}
\label{eq:3-21}
k1 = {\bf f} ({\bf X}, t)
\end{eqnarray}

ただし${bf X} = (x,y,z)$であり、${\bf f} ({\bf X}, t)$は時刻$t$、座標(x,y,z)における速度ベクトルである。

k2は式\ref{eq:3-22}で計算する。

\begin{eqnarray}
\label{eq:3-22}
k2 = {\bf f} ({\bf X} + k1\frac{\Delta t}{2} , t-\frac{\Delta t}{2})
\end{eqnarray}

${bf X} + \frac{\Delta t}{2} k1 = (x + \frac{\Delta t}{2} k1_u ,y+ \frac{\Delta t}{2} k1_v ,z+ \frac{\Delta t}{2} k1_w )$であり、${\bf f} ({\bf X} + \frac{\Delta t}{2} k1, t-\frac{\Delta t}{2})$は時刻$t-\frac{\Delta t}{2}$、座標$ (x + \frac{\Delta t}{2} k1_u ,y+ \frac{\Delta t}{2} k1_v ,z+ \frac{\Delta t}{2} k1_w )$における速度ベクトルである。

k3は式\ref{eq:3-23}で計算する。

\begin{eqnarray}
\label{eq:3-23}
k3 = {\bf f} ({\bf X} + k2\frac{\Delta t}{2} , t-\frac{\Delta t}{2})
\end{eqnarray}

k4は式\ref{eq:3-24}で計算する。

\begin{eqnarray}
\label{eq:3-24}
k4 = {\bf f} ({\bf X} + k3\Delta t , t-\Delta t)
\end{eqnarray}

k1からk4を用いて、ステップ時間前の座標は次式のようになる。

\begin{eqnarray}
{\bf X}^{(t-1)} = {\bf X}^{t} - \frac{\Delta t}{6} (k1 + 2k2 + 2k3 + k4)
\end{eqnarray}

このようにして遡った地点を一日ごとにサンプリングする。
サンプリングは線形補間で行う。
\if0
MOVEデータの仕様を説明して、何回データをダウンロードするかとか書ける
\fi

\subsection{漁獲実績データ}
本研究で使用する漁獲実績データは、日本近海の太平洋沖におけるアカイカの漁獲実績データある。
漁獲実績データには日付、緯度、経度、漁獲量、操業開始時間、操業終了時間、CPUE（Catch Per Unit Effort）値が記録されている。
CPUE値は単位釣り機が単位時間に捕獲したアカイカの重量を表している。
すべての漁船に搭載される釣り機が同じ性能であると仮定すると、CPUE値はその海域での魚群の密度を反映する値であるとできる。
このことから、CPUE値は漁場予測において重要な値である。
また、この漁獲実績データは、HSIモデリング結果を可視化する際に漁を行った地点をマーキングするためにも使用する。
例えば、太平洋の漁獲実績を基に日本海での漁獲量を予測しようとしても、それぞれの漁獲に関連がないので、有効な予測をすることはできない。
漁を行った地点をマーキングすることで、HSIモデリングの有効な範囲を大まかに把握することができる。

\section{HSIモデルから漁獲量予測への変換}
先に説明したようにHSIはその地点が対象生物の生息地として適しているかどうかを0から1で数値化したモデルである。
一方、漁獲量を表すCPUEは単位釣り機が単位時間に捕獲した対象生物の重量である。
これらが比例関係にあると仮定することで漁獲予測に関する過去の研究が行われてきた。
HSI=0の時は対象生物がおらずCPUE=0となり、HSI=1の時は対象生物が最大数おりCPUE=maxとなるとすると、その変換は式\ref{eq:3-0}で行うことができる。

\begin{eqnarray}
\label{eq:3-0}
PredictedCPUE &=& (maxCPUE-0) \times HSI \\
&=& maxCPUE \times HSI
\end{eqnarray}

PredictedCPUEは漁獲量予測、maxCPUEは観測された最大CPUEである。
本研究ではHSIとCPUEの変換をこの式で行う。

\section{SIモデル}
漁獲量を単一の海洋環境変数から説明するモデルがSIモデルである。以下では従来のSIモデル構築手法と提案手法を説明し、その違いを述べる。

\section{従来手法によるSIモデル構築}
従来手法でのSIモデル構築は次の手順で行う。
まず、SIモデルを構築したい変数について、深さインデックスを一つ選ぶ。
実測した漁獲点から垂直に見た時の深さインデックスでの変数値と、その漁獲点でのCPUEを散布図に描点する。
次に平滑化パラメータを一つ設定し、散布図を平滑化スプラインで近似する。
深さインデックスの選択と、平滑化パラメータの設定を繰り返し、利用者が最適と判断したスプライン曲線をSIモデルとする。
これを変数ごとに行うことで、各SIモデルを構築する。
この手法でSIモデルを構築する場合、変数値とCPUEの散布図を作成する時点で漁獲を行った時刻の情報が失われる。
そのため、SIモデルの時間変化を考慮することができない。
そこで、SIモデルが変化しないよう短い時間幅でモデルを構築する必要がある。
\if0
散布図の例
\fi
この散布図をスプライン曲線で近似することで、SIモデルを構築する。
\if0
スプライン曲線で近似する方法の説明
\fi
次の変数でも同様に深さインデックスを選び直しスプライン曲線で近似する。
こうすることで5種のSIモデルを構築できる。

\section{提案手法によるSIモデル構築}
提案手法でのSIモデルの構築を説明する。
本研究で使用する海洋環境変数データは5種の変数、塩分濃度、温度、緯度方向の流速、経度方向の流速、深さ方向の流速からなる。
また各変数は特定の深さごとに値を持っており、それらの線形和を使ってSIモデル構築をする場合、次式で表すことができる。

\begin{eqnarray}
SI = \sum_{i=0}^{depth} a_i x_i
\label{eq:3-1}
\end{eqnarray}

$x_i$ は漁獲点の鉛直方向深さiでの海洋環境変数の値、$a_i$ はその係数である。
さらに過去のデータとして、先に説明した手法で計算した海洋環境変数データを用いると次式でSIモデルを表せる。

\begin{eqnarray}
SI = \sum_{j=0} \sum_{i=0}^{depth} a_ij x_ij
\label{eq:3-5}
\end{eqnarray}

$x_ij$ は漁獲点の鉛直方向の深さiを始点としてj日遡った地点での海洋環境変数の値、$a_ij$ はその係数である。

漁獲点における式(\ref{eq:3-1})のSI値を漁獲量予測に変換した値と漁獲実績(CPUE)との差の絶対値を最小化する $a_ij$ を求めることでSIモデルを構築できる（式\ref{eq:3-6}）。

\begin{eqnarray}
\label{eq:3-6}
& & \argmin_{a_ij} (|CPUE-PredictedCPUE|) \\
&=& \argmin_{a_ij} \left( \left| CPUE-(maxCPUE*\sum_{j=0} \sum_{i=0}^{depth} a_ij x_ij ) \right| \right)
\end{eqnarray}

また、実測した漁獲点は複数存在するのでこれを行列で表すことができる（式\ref{eq:3-7}）。

\begin{eqnarray}
\label{eq:3-7}
\argmin_{\theta} ||{\bf Y}-{\bf X}\theta||_{2}^{2}
\end{eqnarray}

{\bf Y}は$n \times 1$ 行列で、i行目はi番目の漁獲点でのCPUEとなっている。
{\bf X}はk番目の漁獲点で成立する式\ref{eq:3-5}の$x_ij$をk行目に横に並べた行列である。
$\theta$は$n \times 1$行列で{\bf X}における$x_ij$の並びと同じ順である。
式\ref{eq:3-7}ではどの漁獲点でも利用可能なモデルを構築しようとしているので、$x_ij$はどの漁獲点でも同じ係数となる。
そのため、$\theta$は$n \times m$行列ではなく、$n \times 1$行列となる。
式\ref{eq:3-7}は機械学習の分野で教師あり学習と呼ばれたり、回帰問題と呼ばれる問題で最小二乗法などの解法によって解くことができる。
式\ref{eq:3-7}を解くと全ての変数に0でない係数が現れる。
これは全ての深さの全ての変数が漁獲量に影響するということを意味するが、例えばある深さで対象生物を漁獲する際に、同じ日の全く別の深さの海洋環境変数がその漁獲量に影響するとは考えにくく、海洋の専門家も否定している。
また、すべての変数を漁獲モデルに使用するとオーバーフィッティングの問題が発生する。
そのため、漁獲モデルに全ての変数を利用するのではなく、一部を削減する必要がある。

\subsection{オーバーフィッティング}
構築したモデルが、構築に使用したデータに対してはよく適合しているが、未知のデータに対して適合していない状態がオーバーフィッティング（過学習）である。
\if0
オーバーフィッティングの一般的な説明と、今回のデータでオーバーフィッティングの例を示したい
\fi
今回のように計算機による自動計算でモデルを構築する際によく問題となる状態である。
今回の例であれば、実測した漁獲点で予測させた場合は実際のCPUEに近い値が出るが、それを実際の予測に使用すると実際のCPUEとかけ離れたモデルができてしまう。
一般にオーバーフィッティングはモデルの自由度が高すぎる場合に発生する。
そこで、式\ref{eq:3-5}のように使用可能な全ての変数を使用するのではなく、変数の数を減らす工夫をする。
以下で説明する変数の数を減らすモデル構築手法はスパースモデリングとも呼ばれる。
例えば係数行列$\theta$の成分に0の項があれば、実質的に変数の数が減っていることになる。
その手法にはRidge回帰\cite{a9}、Lasso回帰\cite{a8}など様々な手法がある。
Ridge回帰は古くに提案された変数削減手法であり次のように行う。
式\ref{eq:3-7}で示した最小化式に罰則項としてL2ノルムを加えたものである。
Lpノルムは一般にp>=1で定義されるノルムで、式\ref{eq:3-8}で表せる。

\begin{eqnarray}
\label{eq:3-8}
Lp norm = ||x||_p = (|x_0|^p + |x_1|^p + |x_2|^p + ...)^{\frac{1}{p}}
\end{eqnarray}

p=2の場合がL2ノルムであり、次式で示すように各係数の二乗和の平方根となる。

\begin{eqnarray}
\label{eq:3-9}
L2norm = ||x||_2 = (|x_0|^2 + |x_1|^2 + |x_2|^2 + ...)^{\frac{1}{2}} = \sum_i |x_i|^2
\end{eqnarray}

これを罰則項とした上で罰則項そのものの重み$\lambda$も考慮し、式\ref{eq:3-7}に対し適用すると次式となる。

\begin{eqnarray}
\label{eq:3-9}
\argmin_{\theta} \left( ||{\bf Y}-{\bf X}\theta||_{2}^{2} + \lambda \sum_i |\theta_i |^2 \right)
\end{eqnarray}

ただし、$\theta_i$は$\theta$のi番目の成分である。
式\ref{eq:3-9}がRidge回帰である。
Ridge回帰では罰則項が係数の二乗和の平方根であり、変数の数（係数の非0の項の数）については一切制約がない。
しかし、モデルに与える影響の小さい変数に対応する係数は0に近づき、閾値処理によって係数0にできる。
これは次の理由で説明できる。
まず、一般化したRidge回帰において、最小化式は式\ref{eq:3-10}となる。

\begin{eqnarray}
\label{eq:3-10}
min E({\bf w}) + \lambda \sum_{i} | w_i |^{2}
\end{eqnarray}

この目的関数を$w_i$で微分すると次式になる。

\begin{eqnarray}
\label{eq:3-11}
\frac{\partial E({\bf w})}{\partial w_i} + \frac{1}{2} \lambda w_i
\end{eqnarray}

式\ref{eq:3-11}の第一項は特定の$w_i$で0になり、それ未満では正、それより大きい時は負となる。
第二項は$w_i = 0$で0になり、それ未満では負、それより大きい時は正となる。
また、線形回帰の場合第一項は階段関数となる。
そして第一項はその変数がモデルに与える影響の大小に比例する。
そのため、影響が小さい変数の場合、第二項が係数$w_i$決定に支配的となり$w_i$は0に近づく。
一方、影響の大きい変数の場合、第二項が$w_i$決定にはあまり寄与しなくなり、$w_i$はあまり0に近づかない。
そのため、モデル決定に対して影響力の小さい変数は$w_i$が0に近づく。
しかし、この手法では$w_i$が0に近づくほど第二項の影響が小さくなるので$w_i$は完全には0にならず、閾値処理をしないと$w_i$を0にできない。

そこで、Lasso回帰が考案された。
Lasso回帰は罰則項にL1ノルムを用いた手法である。

\begin{eqnarray}
\label{eq:3-12}
L1norm = ||x||_1 = (|x_0|^1 + |x_1|^1 + |x_2|^1 + ...)^{\frac{1}{1}} = \sum_i |x_i|
\end{eqnarray}

L1ノルムとはつまり、係数行列の絶対値の和である。
こちらも変数の数（係数の非0の項の数）についての制約はない。
しかし、実際には係数の一部が0になる。
それを以下で説明する。

一般化したLasso回帰の最小化式は次式となる。

\begin{eqnarray}
\label{eq:3-13}
min E({\bf w}) + \lambda \sum_{i} | w_i |
\end{eqnarray}

この目的関数を$w_i$で微分すると次式になる。

\begin{eqnarray}
\label{eq:3-14}
\frac{\partial E({\bf w})}{\partial w_i} + \lambda sgn(w_i)
\end{eqnarray}

sgn(x)は符号関数である。
これも先と同様に考えると$w_i$は第二項を入れない場合と比較し、0に近づく。
しかし、符号関数は$w_i$の正負のみで$w_i$の大小に関わらない値を持つ。
そのため第一項が小さく、モデルに対する影響の小さい変数は$w_i = 0$に収束する。
これにより、Ridge回帰のような閾値処理を用いることなく、変数の削減が可能である。

Lasso回帰は影響の小さい変数の係数が0に収束するが、あくまで罰則項は係数の絶対値の和である。
そのため、ある変数が別の変数と従属の関係にあり、モデルに与える影響が大きい場合、どちらの変数もモデルに残ってしまう。
つまり、Lasso回帰では削減できないが、モデル構築に不要な変数が存在してしまう場合がある。

そこで罰則項として、係数行列 $\theta$ のL0ノルムと重み$\lambda$ の積を加えた次式を考える。

\begin{eqnarray}
\label{eq:3-2}
\argmin_{\theta} \left( ||{\bf Y}-{\bf X}\theta||_{2}^{2} + \lambda \sum_i ||\theta_i ||_0 \right)
\end{eqnarray}

式\ref{eq:3-8}はp>=1の場合で定義されているが、それをp=0の場合にも拡張することでL0ノルムは次式で表せる。

\begin{eqnarray}
\label{eq:3-3}
L0norm = ||x||_0 = (|x_0|^0 + |x_1|^0 + |x_2|^0 + ...)^{\frac{1}{0}} = \sum_i \left( |x_i|^0 \right) ^ \infty
\end{eqnarray}

$0^0=0$ と定義した場合、$x_i = 0$のとき$0^{\infty} = 0$ 、$x_i \neq 0$のとき$1^{\infty} = 1$となる。
つまり、式(\ref{eq:3-3})は$x_i$ の非ゼロ成分の数となる。
この場合、罰則項は変数の数に比例するのでLasso回帰の場合の問題も発生しない。
また、変数の数を削減することでオーバーフィッティングの問題も発生しにくい。

本研究は以上の理由より、L0ノルムを罰則項としてモデル構築に使用する。
次に、最適化式\ref{eq:3-2}をどのようにして解くか説明する。

\section{提案手法のアルゴリズム}
先に述べた計算手法を計算機上で実現するアルゴリズムについて説明する。
\if0
この問題のNP困難性の説明
\fi

\section{IRLS}
IRLSとは
\if0
なぜこのアルゴリズムが変数を減らす方向に働くのか
→まずWを更新する（Wは対角行列でi番目の係数の逆数が入っている）
つぎに係数行列を最小二乗法で解く。（最小二乗法なのでここで最適化計算）
最適化計算の中にWが入っている（Wは係数0で最小になる）
このときに係数が減る
まとめると今回のアルゴリズムは最小化問題を何度も解いて、係数行列が収束したら終わるようになっている
また、各最小化問題は項の中にL0ノルムが入っているので、係数を0にする方向に働く（正則化のwikipediaになぜそう働くのか書いてある）
→最小化計算部分をただの逆行列計算と勘違いしていたからわからなかった
\fi

\section{最適な罰則項の重みの決定}
先に説明したIRLSアルゴリズムによって、L0ノルムを罰則項としたモデル構築が可能である。
一方、モデルにはまだ罰則項の重みが自由度として残っている。
そのため、これも最適化する必要がある。
この最適化は次に説明する正答率が最大となる重みを選択することによって行う。
選ばれた重みを用いて最適化された漁獲モデルが、その海洋環境変数のSIモデルとなる。

\section{正答率}
本研究では正答率によって重みの選択を行う。
ここでは正答率の説明を行う。
まずテストデータの漁獲点情報を用いてCPUEを予測する。
また、学習データ内の実測値としてのCPUEの平均値を求める。
予測したCPUEと学習データの平均CPUEを比較した時の大小を求める。
次に、先ほど予測した漁獲点で観測された実際のCPUEと学習データの平均CPUEを比較した時の大小を求める。
これらが一致するかどうかを全てのテストデータに対し求めることで正答率とした。
\if0
なぜ予測CPUEの距離ではなくCPUEの正答率なのか
\fi

\section{HSIモデル構築}
先程のSIモデル構築を各海洋環境変数ごとに適用することで、対象魚種にとっての好適な各海洋環境変数がわかる。
それらの相乗平均をHSIモデルとすることで、対象魚種の最適な海洋環境の分布がわかる。
\if0
SIからHSIモデルを求める方法はいくつかある
その中で過去の研究ではなぜ相乗平均だったのか書く
\fi

\begin{eqnarray}
HSI = \sqrt{ \sum SI} = \sqrt{ \sum \sum_{k=0}^{depth} a_k x_k } 
\label{eq:3-4}
\end{eqnarray}
